__author__ = "[Michelle Lee]"
__email__ = "[msl2229@columbia.edu]"

# ======================================================================#
# *#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
import time
from collections import deque
import resource
import heapq

# ======================================================================#

# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#

import argparse

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
    parser.add_argument('-bfs', action="store_true", default=False, help="Run BFS on the map")
    parser.add_argument('-dfs', action="store_true", default=False, help="Run DFS on the map")
    parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
    parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
    parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
    parser.add_argument('-m', action="store", help="Map filename")

    results = parser.parse_args()

    if results.m == "" or not (results.all or results.astar or results.bfs or results.dfs or results.ida):
        print("Check the parameters : >> python hw1_UNI.py -h")
        exit()

    if results.all:
        results.bfs = results.dfs = results.astar = results.ida = True

    # Reading of map given and all other initializations
    try:
        with open(results.m) as f:
            arena = f.read()
            arena = arena.split("\n")
    except:
        print("Error in reading the arena file.")
        exit()

    # Internal representation
    print(arena)

    print("The arena of size " + str(len(arena)) + "x" + str(len(arena[0])))
    print("\n".join(arena))


class MazeState:
    '''
    This class is an abstraction to store a maze state, which contains the following:
    - Maze configuration (arena)
    - Current Position (position in the the maze that the current state represents)
    - Parent (the state from which the current state came from)
    - Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
    - Cost (Cost  of the path taken from the start to the current state)
    - Children (a child of the current state is generated by moving in a direction)
    '''

    def get_start_index(self):
        '''
        Returns the start index of the maze based on the given arena
        returns (-1, -1) if no start index found
        '''
        # =======================================================================#
        for i in range(len(self.arena)):
            for j in range(len(self.arena[i])):
                if arena[i][j] == "s":
                    return (i, j)
        return (-1, -1)

    # =================================#

    def get_goal_index(self):
        '''
        Returns the goal index of the maze based on the given arena
        returns (-1, -1) if no goal index found
        '''
        # ======================================================================#
        for i in range(len(self.arena)):
            for j in range(len(self.arena[i])):
                if arena[i][j] == "g":
                    return (i, j)
        return (-1, -1)

    # =================================#

    def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1, -1)):

        self.arena = arena
        self.parent = parent
        self.action = action
        self.cost = cost
        self.children = []

        self.start = self.get_start_index()
        self.start = self.get_start_index()
        self.goal = self.get_goal_index()

        if (current_position[0] == -1):
            self.current_position = self.start
        else:
            self.current_position = current_position

    def display(self):
        print("\n".join(self.arena))

    def move_up(self):
        '''
        This function is supposed to check if up is a valid move from the given state.
        If up is a valid move, returns a child in which the player has moved up
        Else returns None.
        '''
        # =================================================================#
        row = (self.current_position[0] - 1)
        col = self.current_position[1]
        if row < 0:
            return None

        if self.arena[row][col] != "o" and self.arena[row][col] != "s":
            #new_child = self.expand()
            new_child = MazeState(self.arena, parent=self, action='Up', cost=self.cost + 1, current_position=(row, col))
            return new_child
        return None
    #=================================#

    def move_down(self):
        row = (self.current_position[0] + 1)
        col = self.current_position[1]
        if row >= len(self.arena):
            return None

        if self.arena[row][col] != "o" and self.arena[row][col] != "s":
            #new_child = self.expand()
            new_child = MazeState(self.arena, parent=self, action='Up', cost=self.cost + 1, current_position=(row, col))
            return new_child
        return None

    def move_left(self):
        row = self.current_position[0]
        col = (self.current_position[1] - 1)

        if col < 0:
            return None

        #if self.arena[row][col] == " ":
        if self.arena[row][col] != "o" and self.arena[row][col] != "s":
            #new_child = self.expand()
            new_child = MazeState(self.arena, parent=self, action='Up', cost=self.cost + 1, current_position=(row, col))
            return new_child
        return None


    def move_right(self):
        row = self.current_position[0]
        col = (self.current_position[1] + 1)
        if col >= len(self.arena[0]):
            return None

        if self.arena[row][col] != "o" and self.arena[row][col] != "s":
            #new_child = self.expand()
            new_child = MazeState(self.arena, parent=self, action='Up', cost=self.cost + 1, current_position=(row, col))
            return new_child
        return None

    def expand(self):
        """
        Generate the child nodes of this node
        """
        if (len(self.children) != 0):
            return self.children

        # Do not change the order in this function, since the grading script assumes this order of expansion when checking
        children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

        self.children = [state for state in children if state is not None]
        return self.children

    def dfs_expand(self):
        """
        Generate the child nodes of this node
        """
        if (len(self.children) != 0):
            return self.children

        children = [self.move_left(), self.move_down(), self.move_right(), self.move_up()]

        self.children = [state for state in children if state is not None]
        return self.children

    def __hash__(self):
        '''
        Maze states hashed based on cost.
        This function may be modified if required.
        '''
        # ============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
        # ============================================================================================#

        return self.cost

    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#

    def __eq__(self, other):
        '''
        Maze states are defined as equal if they have the same dimensions and the same current position.
        This function may be modified if required.
        '''

        # =============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
        # =============================================================================================#

        m1 = self.arena
        m2 = other.arena

        if (len(m1) != len(m2)):
            return False

        for i in range(0, len(m1)):
            if (not (m1[i] == m2[i])):
                return False

        return self.current_position == other.current_position

    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


    def __lt__(self, other):

        return self.cost < other.cost

# =====================================================================================#
# *#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
# =====================================================================================#

# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#


# ================================================================================#
# *#*#*# Optional: You may write helper functions in this space if required #*#*#*#
# ================================================================================#

# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#

'''
path to goal:
cost: 
nodes expanded: 
max nodes stored: 
running time: 
max ram usage:
'''
'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''

def bfs(arena):
    dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    start_time = time.time()
    nodes_expanded = 0
    max_nodes_stored = 0
    max_search_depth = 0

    initial_state = MazeState(arena, parent=None, action='Start', cost=0, current_position=(-1,-1))
    start_pos = initial_state.get_start_index()
    initial_state.current_position = start_pos
    frontier = deque([initial_state])
    explored = set()

    while len(frontier) > 0:
        state = frontier.popleft()
        explored.add(state.current_position)

        if (state.current_position == initial_state.get_goal_index()):
            # NOTE: can't just return state, need to return everything from hw
            end_time = time.time()
            running_time = end_time - start_time
            dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram)/(2**10)

            #find path
            path = deque()
            while state.current_position != initial_state.get_start_index():
                path.append(state.current_position)
                state = state.parent

            #arena as string:
            path_arena = initial_state.arena
            path_arena = [list(row) for row in initial_state.arena]
            for i in range(len(arena)):
                for j in range(len(arena[i])):
                    for pos in path:
                        if i == pos[0] and j == pos[1]:
                            if path_arena[i][j] != "g":
                                path_arena[i][j] = "*"
            path_arena = [''.join(row) for row in path_arena]

            #print(path)
            return (path_arena, len(path), nodes_expanded, max_nodes_stored, max_search_depth, running_time, dfs_ram)

        children = state.expand()
        nodes_expanded += 1
        for child in children:
            if child.current_position not in explored and child not in frontier:
                frontier.append(child)
                max_search_depth = max(max_search_depth, child.cost)
        print(len(frontier))
        nodes_stored = len(frontier) + len(explored)
        max_nodes_stored = max(max_nodes_stored, nodes_stored)
    return (arena, None, None, None, None, None, None)
# return [], -1, -1, -1, -1, -1, -1 # Replace with return values
# return (path, len(path), nodes_expanded, max_nodes_stored, running_time, dfs_ram)

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def dfs(arena):
    start_time = time.time()
    dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    initial_state = MazeState(arena, parent=None, action='Start', cost=0, current_position=(-1, -1))
    start_pos = initial_state.get_start_index()
    initial_state.current_position = start_pos
    frontier = []
    frontier.append(initial_state)
    explored = set()
    nodes_expanded = 0
    max_nodes_stored = 0
    max_search_depth = 0

    while len(frontier) > 0:
        state = frontier.pop()
        explored.add(state.current_position)

        if(state.current_position == initial_state.get_goal_index()):
            # find path
            path = deque()
            while state.current_position != initial_state.get_start_index():
                path.append(state.current_position)
                state = state.parent
            #if state.current_position == initial_state.get_goal_index():
                #temp = state
                #while temp is not None:
                    #path_arena.append(str(temp.arena))
                    #temp = temp.parent
                #path_arena = [''.join(row) for row in state.arena]
            # arena as string:
            path_arena = initial_state.arena
            path_arena = [list(row) for row in initial_state.arena]
            for i in range(len(arena)):
                for j in range(len(arena[i])):
                    for pos in path:
                        if i == pos[0] and j == pos[1]:
                            if path_arena[i][j] != "g":
                                path_arena[i][j] = "*"
            path_arena = [''.join(row) for row in path_arena]

            end_time = time.time()
            running_time = end_time - start_time
            dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram) / (2 ** 10)
            return (path_arena, len(path), nodes_expanded, max_nodes_stored, max_search_depth, running_time, dfs_ram)

        nodes_expanded += 1
        children = state.dfs_expand()
        for child in children:
            if child.current_position not in explored and child not in frontier:
                frontier.append(child)
                max_search_depth = max(max_search_depth, child.cost)
        nodes_stored = len(frontier) + len(explored)
        max_nodes_stored = max(max_nodes_stored, nodes_stored)

    return (arena, None, None, None, None, None, None)

#return [], -1, -1, -1, -1, -1, -1  # Replace with return values
# return (path, len(path), nodes_expanded, max_nodes_stored, running_time, dfs_ram)
# =================================#
def mh_dist(node1, node2):
    answer = abs((node1[0] - node2[0]) + (node1[1] - node2[1]))
    return answer
'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def astar(arena):
    start_time = time.time()
    dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    initial_state = MazeState(arena, parent=None, action='Start', cost=0, current_position=(-1, -1))
    goal = initial_state.get_goal_index()
    cost = initial_state.cost
    #start_pos = initial_state.get_start_index()
    #initial_state.current_position = start_pos
    frontier = []
    initial_mh = initial_state.cost + mh_dist(initial_state.current_position, goal)
    initial_state.cost += mh_dist(initial_state.current_position, goal)
    heapq.heappush(frontier,  (initial_mh, initial_state))
    #heapq.heappush(frontier, initial_state)
    explored = set()
    nodes_expanded = 0
    max_nodes_stored = 0
    max_search_depth = 0
    cost_g = 0

    while len(frontier) > 0:
        f_n, state = heapq.heappop(frontier)
        #state = heapq.heappop(frontier)
        #state_object = state[1]
        #explored.add(state_object.current_position)
        explored.add(state.current_position)
        #print(frontier)
        #print(explored)
        if state.current_position == initial_state.get_goal_index():
            # find path
            path = deque()
            while state.current_position != initial_state.get_start_index():
                cost += 1
                path.append(state.current_position)
                state = state.parent

            # arena as string:
            path_arena = initial_state.arena
            path_arena = [list(row) for row in initial_state.arena]
            for i in range(len(arena)):
                for j in range(len(arena[i])):
                    for pos in path:
                       if i == pos[0] and j == pos[1]:
                            if path_arena[i][j] != "g":
                                path_arena[i][j] = "*"
            path_arena = [''.join(row) for row in path_arena]

            end_time = time.time()
            running_time = end_time - start_time
            dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram) / (2 ** 10)
            return (path_arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, dfs_ram)

        nodes_expanded += 1
        children = state.expand()
        for child in children:
            heuristic = child.cost + mh_dist(child.current_position, goal)
            if child.current_position not in explored and all(child.current_position != n[1].current_position for n in frontier):
            #all(child.current_position != n[1].current_position for n in frontier)):
                heapq.heappush(frontier, (heuristic, child))
            elif any(child.current_position == n[1].current_position for n in frontier):
            #((any(child.current_position == n[1].current_position for n in frontier)):
                for i, (other_val, other_node) in enumerate(frontier):
                    if (heuristic < other_val and other_node.current_position == child.current_position):
                        print("POTENTIAL: ", other_node.current_position)
                        heapq.heappush(frontier, (heuristic, child))
                        #frontier[i] = (heuristic, child)
                        #heapq.heapify(frontier)
        max_search_depth = max(max_search_depth, state.cost)
        nodes_stored = len(frontier) + len(explored)
        max_nodes_stored = max(max_nodes_stored, nodes_stored)
    return (arena, None, None, None, None, None, None)

#return [], -1, -1, -1, -1, -1, -1  # Replace with return values
# return (path, len(path), nodes_expanded, max_nodes_stored, running_time, dfs_ram)
# =================================#

'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''

def ida(arena):
    start_time = time.time()
    dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    initial_state = MazeState(arena, parent=None, action='Start', cost=0, current_position=(-1, -1))
    goal = initial_state.get_goal_index()
    nodes_expanded = 0
    max_nodes_stored = 0
    max_search_depth = 0
    cost = 0

    maxCost = mh_dist(initial_state.current_position, goal)
    #loop do:
    print("ida while")
    while(1):
        result = depth_limited_search(initial_state, goal, maxCost, start_time, dfs_start_ram, nodes_expanded, max_nodes_stored, max_search_depth, cost)
        if result == None:
            return (arena, None, None, None, None, None, None)
        else:
            return result
        #result = depth_limited_search(initial_state, goal, maxCost)

        #if result != maxCost:
        #if result is None:
            #print("none")
            #break
        #elif result.cost < maxCost:
            #print("result.cost < maxcost")
            #maxCost = result.cost
        #elif result.cost == maxCost:
            #print("result.cost == maxcost")
            #trace path through parents?
            #path = deque()
            #while result.current_position != initial_state.get_start_index():
                #cost += 1
                #path.append(result.current_position)
                #result = result.parent

    #return (arena, None, None, None, None, None, None)
#return [], -1, -1, -1, -1, -1, -1  # Replace with return values
# =================================#

#ADD MANHATTAN DISTANCE!!!!!!!!!
#look at cuttoff

#function DEPTH-LIMITED-SEARCH(problem, l) returns a node or failure or cutoff
def depth_limited_search(initial_state, goal, maxCost, start_time, dfs_start_ram, nodes_expanded, max_nodes_stored, max_search_depth, cost):
    #frontier + a LIFO queue (stack) with NODE(problem.INITIAL) as an element
    #goal = initial_state.get_goal_index()
    frontier = []
    initial_mh = initial_state.cost + mh_dist(initial_state.current_position, goal)
    #initial_mh = initial_state.cost
    #initial_state.cost += mh_dist(initial_state.current_position, goal)
    heapq.heappush(frontier, (initial_mh, initial_state))
    result = None
    next_maxCost = float('inf')

    #while not Is-EMPTY(frontier) do
    while len(frontier) > 0:
        #print("while")
        f_n, state = heapq.heappop(frontier)
        nodes_expanded += 1
        if state.current_position == initial_state.get_goal_index():
            # find path
            path = deque()
            while state.current_position != initial_state.get_start_index():
                cost += 1
                path.append(state.current_position)
                state = state.parent

            # arena as string:
            path_arena = initial_state.arena
            path_arena = [list(row) for row in initial_state.arena]
            for i in range(len(arena)):
                for j in range(len(arena[i])):
                    for pos in path:
                        if i == pos[0] and j == pos[1]:
                            if path_arena[i][j] != "g":
                                path_arena[i][j] = "*"
            path_arena = [''.join(row) for row in path_arena]
            end_time = time.time()
            running_time = end_time - start_time
            dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram) / (2 ** 10)
            return(path_arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, dfs_ram)
            # return (path, len(path), nodes_expanded, max_nodes_stored, running_time, dfs_ram)
        if f_n > maxCost:
            next_maxCost = f_n
            #print("next_maxCost: ", next_maxCost)

        elif f_n <= maxCost:
            #print("here 3: ", maxCost)
            #for each child in ExPAND (problem, node) do
            children = state.expand()
            for child in children:
                heuristic = child.cost + mh_dist(child.current_position, goal)
                if all(child.current_position != n[1].current_position for n in frontier):
                    #print("pushed: ", child.current_position)
                    heapq.heappush(frontier, (heuristic, child))
            max_search_depth = max(max_search_depth, state.cost)
            max_nodes_stored = max(max_nodes_stored, len(frontier))
        #print("CP: ", state.current_position)

    return depth_limited_search(initial_state, goal, next_maxCost, start_time, dfs_start_ram, nodes_expanded, max_nodes_stored, max_search_depth, cost)

if __name__ == "__main__":
    if results.bfs:
        print("\nBFS algorithm called")
        bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(
            arena)
        print("\n".join(bfs_arena))
        print("BFS:")
        print("Cost: " + str(bfs_cost))
        print("Nodes Expanded: " + str(bfs_nodes_expanded))
        print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
        print("Max Search Depth: " + str(bfs_max_search_depth))
        print("Time: " + str(bfs_time) + "s")
        print("RAM Usage: " + str(bfs_ram) + "kB\n")

    if results.dfs:
        print("\nDFS algorithm called")
        dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(
            arena)
        print("\n".join(dfs_arena))
        print("DFS:")
        print("Cost: " + str(dfs_cost))
        print("Nodes Expanded: " + str(dfs_nodes_expanded))
        print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
        print("Max Search Depth: " + str(dfs_max_search_depth))
        print("Time: " + str(dfs_time) + "s")
        print("RAM Usage: " + str(dfs_ram) + "kB\n")

    if results.astar:
        print("\nA* algorithm called")
        astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(
            arena)
        print("\n".join(astar_arena))
        print("A*:")
        print("Cost: " + str(astar_cost))
        print("Nodes Expanded: " + str(astar_nodes_expanded))
        print("Max Nodes Stored: " + str(astar_max_nodes_stored))
        print("Max Search Depth: " + str(astar_max_search_depth))
        print("Time: " + str(astar_time) + "s")
        print("RAM Usage: " + str(astar_ram) + "kB\n")

    if results.ida:
        print("\nIterative Deepening A* algorithm called")
        ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(
            arena)
        print("\n".join(ida_arena))
        print("Iterative Deepening A*:")
        print("Cost: " + str(ida_cost))
        print("Nodes Expanded: " + str(ida_nodes_expanded))
        print("Max Nodes Stored: " + str(ida_max_nodes_stored))
        print("Max Search Depth: " + str(ida_max_search_depth))
        print("Time: " + str(ida_time) + "s")
        print("RAM Usage: " + str(ida_ram) + "kB\n")